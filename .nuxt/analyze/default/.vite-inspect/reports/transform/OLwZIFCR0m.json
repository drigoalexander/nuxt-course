{
  "resolvedId": "/Users/drigoalexander/Documents/Practice/NUXT/nuxt-course/node_modules/@supabase/postgrest-js/dist/module/PostgrestQueryBuilder.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import PostgrestFilterBuilder from './PostgrestFilterBuilder';\nexport default class PostgrestQueryBuilder {\n    constructor(url, { headers = {}, schema, fetch, }) {\n        this.url = url;\n        this.headers = headers;\n        this.schema = schema;\n        this.fetch = fetch;\n    }\n    /**\n     * Perform a SELECT query on the table or view.\n     *\n     * @param columns - The columns to retrieve, separated by commas. Columns can be renamed when returned with `customName:columnName`\n     *\n     * @param options - Named parameters\n     *\n     * @param options.head - When set to `true`, `data` will not be returned.\n     * Useful if you only need the count.\n     *\n     * @param options.count - Count algorithm to use to count rows in the table or view.\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     */\n    select(columns, { head = false, count, } = {}) {\n        const method = head ? 'HEAD' : 'GET';\n        // Remove whitespaces except when quoted\n        let quoted = false;\n        const cleanedColumns = (columns !== null && columns !== void 0 ? columns : '*')\n            .split('')\n            .map((c) => {\n            if (/\\s/.test(c) && !quoted) {\n                return '';\n            }\n            if (c === '\"') {\n                quoted = !quoted;\n            }\n            return c;\n        })\n            .join('');\n        this.url.searchParams.set('select', cleanedColumns);\n        if (count) {\n            this.headers['Prefer'] = `count=${count}`;\n        }\n        return new PostgrestFilterBuilder({\n            method,\n            url: this.url,\n            headers: this.headers,\n            schema: this.schema,\n            fetch: this.fetch,\n            allowEmpty: false,\n        });\n    }\n    /**\n     * Perform an INSERT into the table or view.\n     *\n     * By default, inserted rows are not returned. To return it, chain the call\n     * with `.select()`.\n     *\n     * @param values - The values to insert. Pass an object to insert a single row\n     * or an array to insert multiple rows.\n     *\n     * @param options - Named parameters\n     *\n     * @param options.count - Count algorithm to use to count inserted rows.\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     *\n     * @param options.defaultToNull - Make missing fields default to `null`.\n     * Otherwise, use the default value for the column. Only applies for bulk\n     * inserts.\n     */\n    insert(values, { count, defaultToNull = true, } = {}) {\n        const method = 'POST';\n        const prefersHeaders = [];\n        if (this.headers['Prefer']) {\n            prefersHeaders.push(this.headers['Prefer']);\n        }\n        if (count) {\n            prefersHeaders.push(`count=${count}`);\n        }\n        if (!defaultToNull) {\n            prefersHeaders.push('missing=default');\n        }\n        this.headers['Prefer'] = prefersHeaders.join(',');\n        if (Array.isArray(values)) {\n            const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), []);\n            if (columns.length > 0) {\n                const uniqueColumns = [...new Set(columns)].map((column) => `\"${column}\"`);\n                this.url.searchParams.set('columns', uniqueColumns.join(','));\n            }\n        }\n        return new PostgrestFilterBuilder({\n            method,\n            url: this.url,\n            headers: this.headers,\n            schema: this.schema,\n            body: values,\n            fetch: this.fetch,\n            allowEmpty: false,\n        });\n    }\n    /**\n     * Perform an UPSERT on the table or view. Depending on the column(s) passed\n     * to `onConflict`, `.upsert()` allows you to perform the equivalent of\n     * `.insert()` if a row with the corresponding `onConflict` columns doesn't\n     * exist, or if it does exist, perform an alternative action depending on\n     * `ignoreDuplicates`.\n     *\n     * By default, upserted rows are not returned. To return it, chain the call\n     * with `.select()`.\n     *\n     * @param values - The values to upsert with. Pass an object to upsert a\n     * single row or an array to upsert multiple rows.\n     *\n     * @param options - Named parameters\n     *\n     * @param options.onConflict - Comma-separated UNIQUE column(s) to specify how\n     * duplicate rows are determined. Two rows are duplicates if all the\n     * `onConflict` columns are equal.\n     *\n     * @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If\n     * `false`, duplicate rows are merged with existing rows.\n     *\n     * @param options.count - Count algorithm to use to count upserted rows.\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     *\n     * @param options.defaultToNull - Make missing fields default to `null`.\n     * Otherwise, use the default value for the column. This only applies when\n     * inserting new rows, not when merging with existing rows under\n     * `ignoreDuplicates: false`. This also only applies when doing bulk upserts.\n     */\n    upsert(values, { onConflict, ignoreDuplicates = false, count, defaultToNull = true, } = {}) {\n        const method = 'POST';\n        const prefersHeaders = [`resolution=${ignoreDuplicates ? 'ignore' : 'merge'}-duplicates`];\n        if (onConflict !== undefined)\n            this.url.searchParams.set('on_conflict', onConflict);\n        if (this.headers['Prefer']) {\n            prefersHeaders.push(this.headers['Prefer']);\n        }\n        if (count) {\n            prefersHeaders.push(`count=${count}`);\n        }\n        if (!defaultToNull) {\n            prefersHeaders.push('missing=default');\n        }\n        this.headers['Prefer'] = prefersHeaders.join(',');\n        if (Array.isArray(values)) {\n            const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), []);\n            if (columns.length > 0) {\n                const uniqueColumns = [...new Set(columns)].map((column) => `\"${column}\"`);\n                this.url.searchParams.set('columns', uniqueColumns.join(','));\n            }\n        }\n        return new PostgrestFilterBuilder({\n            method,\n            url: this.url,\n            headers: this.headers,\n            schema: this.schema,\n            body: values,\n            fetch: this.fetch,\n            allowEmpty: false,\n        });\n    }\n    /**\n     * Perform an UPDATE on the table or view.\n     *\n     * By default, updated rows are not returned. To return it, chain the call\n     * with `.select()` after filters.\n     *\n     * @param values - The values to update with\n     *\n     * @param options - Named parameters\n     *\n     * @param options.count - Count algorithm to use to count updated rows.\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     */\n    update(values, { count, } = {}) {\n        const method = 'PATCH';\n        const prefersHeaders = [];\n        if (this.headers['Prefer']) {\n            prefersHeaders.push(this.headers['Prefer']);\n        }\n        if (count) {\n            prefersHeaders.push(`count=${count}`);\n        }\n        this.headers['Prefer'] = prefersHeaders.join(',');\n        return new PostgrestFilterBuilder({\n            method,\n            url: this.url,\n            headers: this.headers,\n            schema: this.schema,\n            body: values,\n            fetch: this.fetch,\n            allowEmpty: false,\n        });\n    }\n    /**\n     * Perform a DELETE on the table or view.\n     *\n     * By default, deleted rows are not returned. To return it, chain the call\n     * with `.select()` after filters.\n     *\n     * @param options - Named parameters\n     *\n     * @param options.count - Count algorithm to use to count deleted rows.\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     */\n    delete({ count, } = {}) {\n        const method = 'DELETE';\n        const prefersHeaders = [];\n        if (count) {\n            prefersHeaders.push(`count=${count}`);\n        }\n        if (this.headers['Prefer']) {\n            prefersHeaders.unshift(this.headers['Prefer']);\n        }\n        this.headers['Prefer'] = prefersHeaders.join(',');\n        return new PostgrestFilterBuilder({\n            method,\n            url: this.url,\n            headers: this.headers,\n            schema: this.schema,\n            fetch: this.fetch,\n            allowEmpty: false,\n        });\n    }\n}\n//# sourceMappingURL=PostgrestQueryBuilder.js.map",
      "start": 1703362405206,
      "end": 1703362405246,
      "sourcemaps": null
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1703362405246,
      "end": 1703362405246,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1703362405246,
      "end": 1703362405246,
      "order": "pre"
    },
    {
      "name": "nuxt:client-fallback-auto-id",
      "start": 1703362405246,
      "end": 1703362405246,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1703362405246,
      "end": 1703362405246,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1703362405246,
      "end": 1703362405246,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1703362405246,
      "end": 1703362405246,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1703362405246,
      "end": 1703362405246,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1703362405246,
      "end": 1703362405246,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1703362405246,
      "end": 1703362405246,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1703362405246,
      "end": 1703362405246,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1703362405247,
      "end": 1703362405247,
      "order": "normal"
    },
    {
      "name": "nuxt:chunk-error",
      "start": 1703362405247,
      "end": 1703362405247,
      "order": "normal"
    },
    {
      "name": "nuxt:components:imports",
      "start": 1703362405247,
      "end": 1703362405247,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1703362405247,
      "end": 1703362405247,
      "order": "normal"
    },
    {
      "name": "ssr-styles",
      "start": 1703362405247,
      "end": 1703362405247,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1703362405247,
      "end": 1703362405247,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1703362405247,
      "end": 1703362405247,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1703362405247,
      "end": 1703362405247,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1703362405247,
      "end": 1703362405247,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1703362405247,
      "end": 1703362405247,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1703362405247,
      "end": 1703362405247,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1703362405247,
      "end": 1703362405247,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1703362405247,
      "end": 1703362405247,
      "order": "normal"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1703362405247,
      "end": 1703362405247,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1703362405247,
      "end": 1703362405247,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1703362405247,
      "end": 1703362405247,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1703362405247,
      "end": 1703362405247,
      "order": "post"
    },
    {
      "name": "nuxt:runtime-paths-dep",
      "start": 1703362405247,
      "end": 1703362405247,
      "order": "post"
    },
    {
      "name": "nuxt:pure-annotations",
      "start": 1703362405247,
      "end": 1703362405247,
      "order": "post"
    },
    {
      "name": "nuxt:route-injection-plugin",
      "start": 1703362405247,
      "end": 1703362405247,
      "order": "post"
    },
    {
      "name": "nuxt:components-loader",
      "start": 1703362405247,
      "end": 1703362405247,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-composables:transform",
      "start": 1703362405247,
      "end": 1703362405247,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1703362405247,
      "end": 1703362405247,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1703362405247,
      "end": 1703362405247,
      "order": "normal"
    }
  ]
}
